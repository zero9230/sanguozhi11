

# 序

每天夜深人静时，这个g物总会掀起一片血南羅风，饱受摧残的人们苦不堪亩，却只能默默忍受。

"忍？为什么要忍？我们不能杀了它吗I ？”

"当然不能！杀了它我们可部得挂！"

想看小说的可以散了， 这是一篇技术分享。 forest, 截止至今，为集团各Bu近千个应用，共计5W+客服端提供数据包服务。使用forest数据包，能够以极高的性 能读取类目厲性数据。而类目厲性数—为商品的核心元数据，使得许多应用强依赖forest，可以认为它是一个极其 重要的"业务中间件"。

但是，较离的内存占用加上类目厲性数据与日剧增，令不少应用负载重重。而每夜数据包更新时，为保证更新朗间数 据的可读，forest内部会等待新索引完全加载完成，才会释放掉旧索引，因此在这几秒之内同时存储了两份索引。如 果使用的是较大的数据包，索引切換期间内存占用将大大飙升，易引起Full-GC、 load飙高，甚至影响业务服务。 是时候掲秘一下这个怪物了。

# "小怪兽”弗瑞斯特

交易使用的纯类目数据包，数据包压缩包3M，解压后17M，内存占用50M，怪兽长大前都是可以做朋友的，我们先 拿这个数据包看一下结构。 

forest数据包，分为索引文件、存储文件以及字典表文件三种。

如何根据一个类目ID取到类目对象。forest客户端启动时，会加载索引文件，将所有类目反序列化为对象放在一个数组里。数组是按类目ID排好序的。根据ID查找找类目时，通过二分査找，就能快速定位到位置并取出对象，如下图所示。

![image-20211027220218042](%E8%A7%A3%E6%9E%90forest%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.assets/image-20211027220218042.png)

拿到一个类目对象，实际场景中可能需要取到类目的以下信息：



```java
CategoryDO {
  int categoryld; 			//类目ID, —般是通过ID状取g曰M累
  StdCategoryDO parent; //父类目对象
  List<StdCategoryDO> children; //子类目对象
  String name; 					//类目名称
  String memo; 					//类目描述
  String features;			 //类目特征，格式形如"k:v;k:v;"
  int catType; 					//类目类型 
  int channelld; 				//渠道ID,每个类目分脚不同渠道 
  int sortOrder; 				//类目排序值，越小越靠前 
  int coironodityld; 		//品类工D
}
```



而这些信息，是分散存放在索引文件、存储文件以及字典表文件三者中的。

## 索引文件(index)

首先我们看下索引文件，对于只有类目的数据包来说，索引文件里很简单，就只有类目的索引信息。

![image-20211027221857297](%E8%A7%A3%E6%9E%90forest%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.assets/image-20211027221857297.png)

可以与上面的`categoryDO`对比。

1. parent与children, 在索引节点中有对应的parentld字段与children数组，要获取父/子类目对象，根据其id再进行次或n次二分查找即可。
2. name、memo与features，在索引节点中，井没有strjng型的字段，取而代之的是nameld、 memold以及 featureld，这些Id存放的是具体字符串在字典表中的位置，字典表结构见下文。
3. 剩余的catType、 channelId, sortorder以及commodityld字段，在索引中没有对应的字段，只有一个recordId， record的作用见下文存储文件的结构。

## 存储文件(store)

除了索引信息，其它字段大多放进了存储文件中。

存储文件通过`MappedByteBuffer` 映射到堆外内存，结构如下图所示。

![image-20211027222733346](%E8%A7%A3%E6%9E%90forest%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.assets/image-20211027222733346.png)

存储文件里存放的部是定长的数据，当需要取某个类目的存储信息时，从索引结构中获取到`recordId`,然后通过读取下标的方法即可计算出对应信息在文件中的位置。

```java
int getposition(int metaBeadsize, int recordld, int recordSize) {
  return metaHeadSize + recordld * recordSize;
}
```



取到`position`后，根据`position`和`recordsize`从整个`mappedByteBuffer`中截取出只包含某个类目存储信息的`subBuffer`。

```java
Buffer subBuffer(Buffer buffer, int position,int recordSize) {
  Buffer subBuffer = buffer.duplicate(); 
  subBuffer.position(position); 
  subBuffer.limit(recordSize + position);
  return subBuffer;
}
```



随后即可从subBueer中获取各个字段的信息



```java
CatRecord getcBtRecord(Buffer in) {
  CatRecord record = new CatRecord();
  record.catld = in.getlnt();
  record.catType = in.getlnt();
  record.channeLId = in.getlnt();
  record.sortOrder = in.getlnt();
  record.commodityld = in.getlnt();
  return record;
}
```



forest单个存储文件小的上百M, 最大的已经超过1.3G, 针对大文件，内存映射读取速度比1/0流快的多。通过内存映 射交给系统层面的swap分区进行管理，能减少许多内存压力，同时保证性能。

## 字典表文件(string dictionary)

字典表文件，其实很简单，它存放了本数据包中使用到的所有字符串，比如类目名称、类目属性別名、类目属性值的特征等等。如下图所示。

![image-20211027232641033](%E8%A7%A3%E6%9E%90forest%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.assets/image-20211027232641033.png)

结构是长度+对应长度的字符串内容。索弓I中的nameld、 memold, featureld, 即是一个个指向字典表中的指针。

为什么单独把字符串提取出来存放？

1. 如果把string型字段也放在存储文件中，会大大增加对象反序列化的耗时。

2. 使整个存储文件中结构化极强，每个数据记录都是定长的，能够快速计算出记录对应的文件位置。

3. 方便做到客户端的向下兼容

4. 有大量的类目属性/类目属性值的feature是完全相同的，还有很多ID不同的属性，属性名是一样的，统一存放的

合影

![image-20211028003604299](%E8%A7%A3%E6%9E%90forest%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.assets/image-20211028003604299.png)



可以参考图中红线指向，理解索引、存储、字典表三者的联系。 

# 长大后为什么不快乐

以`IC`使用的数据包为例，压缩包540M, 解压后2.8G, 内存占用950M。（以下计算皆以IG数据包为例) 

这回先看合影，如下图所示。

【此处有图】

首先扫一眼储存文件，与纯类目数据包相比只是多了两个，分别是类目属性和类目属性值的储存文件，而字典表文件，结构和纯类目数据包完全一样。

带上属性、属性值后，唯一变得复杂的就是索引结构。

其实类目上除了存放本身的信息，还存放着一个厲性对象的数组，接口透出为List。数组也是按ID排好序的，通过二分査找可快速定位到确定的属性对象。

```java
CategoryDO {
  int categoryId; 			//类目ID, —般是通过ID获取类目对象
  StdCategoryDO parent; //父类目对象
  List<StdCategoryDO> children; 				//子类目对象
  ...
  List<CategoryPropertyDO> catPropList; //类目厲性对象
}
```



厲性对象是下面这幅模样。

```java
CategoryPropertyDO{
  int categoryld; //类目ID
  int propertyld; //厲性ID
  String name; //类目属性名称
  String memo; //类目属性描述
  String features; //类目属性特征
  int sortOrder; //类目厲性排序值，越小越靠前
  boolean isKeyProp; //是否是关键属性
  booIean isRequired; //是否是必填属性
  List<CategoryPropertyValueDO> catPropValueList;//类目厲性值对象
}
```



但通过类目属性取类目属性值，又有所不同。整个数据包里，数量最多的就是类目厲性值 (1800W+) , 针对这部分数据，forest中对其做了去对象化存储。在索引内存区中，属于类目属性值的只有两个基本类型的数组。一个是long 型的，每个元素都是一个属性值ID, 对应合影中的  `keyStorage[]` ；另一个是int型的，每一个元素都是该类目属性值 的`recordld`, 对应合影中的Bcordstoragea。因为除了这两个信息，其它字段都放在堆外了， `recordId`就是信息在堆外的地址。两个数组是严格对齐的。 

 `keyStorage` 数组中，可以看到图中下标从101到105之间的属性值是按ID排好序的，从159到164之间的属性值是按ID 排好序的，因为101 ~105这5个属性值是挂载品牌属性下的，而159〜164这6个属性值是挂载颜色分类属性下的。即在同类目厲性范围内，是按厲性值ID排好序的，目的还是为了二分査找。

为什么类目厲性(CP)不做去对象化？其实三四年前的设计思路里是打算将CP、 CPV—同去对象化的，现在数据包中cp数量是200W+，是当时的5倍左右，现在CP占用内存150M，估算在当时只占30M, 做了去对象优化收益也不大。但放在现在，这个收益还是很大的，优化B列入后续的Action中。

到此为止，索引结构我们介绍的差不多了，但在forest中，像这样的索引，最多会有三个。合影中的是后台类目-属性-属性值索引，包含前台类目的数据包还会有一个前台类目-属性-属性值索引，结构是完全一样的’除此之外’还有 一个基础属性属性值的索引，和前后台类目索引略有不同，不过原理类似，就不在此过多细挖。

放上一个比较全面的结构图。

【此处有图】

一个IG使用全量数据包，需要950M左右的常驻内存，切换索引时，内存还要增加750M, 总计1.7G。听，机器哭的声 音。（IC机器堆内10个G， 听，穷机器哭的声音）

# 全量之外，增量应运而生

Forest已经两三年没有在白天推包了，为什么呢？简单说，就是推了要出事。

不简单的说，原因有二。

1. 索引切換过程中的双份索弓I对内存的占用过高，白天业务在高峰期，推送极有可能影响各个链路的服务。

2. 是多年来与各行业类目运营小二达成的共识，类目数据一天一变更，白天的操作到凌晨推包后才会生效。而白天是运营同学配置的时间，如果推包，难免会出现运营同学配置到一半，导致半成品推到线上，影响商品的发布与编辑。

 它就像一个几百人维护的代码库，每次配置都是一次代码提交，而只有每天凌晨，才会正式发布一次。

但一次错误类目数据的上线，就有可能导致客服投诉电话排队上百、客户商品无法发布甚至大型促销无法进行等情 况。forest能做什么？它什么都做不了， 推包的风除巨大，大到我们只能告诉运营同学，“不好意思，这边推不了， 等到明天凌晨推包就解决了。”

类目属性每天的数据变更量是非常有限的，如果能够每天以增量的方式更新数据包，就能让这个怪兽安安静静，面对故障，也能够快速响应。

但是forest的内存架构、索引结构如此复杂，如何做到增置更新呢？即使破釜沉舟把索引改了，万一要回滚，那真是连舟都没的翻，练过的都知道，九阳真经里有句口诀，“他强任他强，清风拂山岗。他横由他横，明月照大江。”又何必纠结于全量的内存架构。

最终，我们另辟蹊径，决定开辟一块新的内存区存放增量数据。所有接口调用，先从增量内存区里查找一次，有数据则直接返回，没有则再到全量内存区中访问。这样不会影响全量索引结构，需要回滚时把增量区释放干净即可。

而增量数据通过对接精卫，监听MySQL的binlog获取，整体架构如下，

【此处有图】

淘系的类目体系是公认的复杂，在这样到处充斥了业务逻辑的生态里做增量，嘴上说说是简单的。

比如有个类目想当富二代，今天换个了父类目，但是它继父可不知道自己多了个娃（因为父类目本身是没有变化的， 变的是子类目的`parentld`), 总不能在调用`getChildren`接口时，遍历所有类目问一遍"你爹是我不？"。

同理，给某个类目加属性（类目本身不知道自己多了属性），给某个属性加属性值（属性本身也不知道自己多了属性 值），都会碰到此类问题。

在此，引入两个概念，第一个是Action, 即变更动作本身，Action类型分为 `INSERT/UPDATE/DELETE` ; 第二个是 Relation，即由Action引起的关系变更，Relation的类型分为 `ADD/DELETE` 。

举例如，D类目的父类目从B換成G, 这是一条Action, 它将产生两条Relation:

1. B与D断绝父子关系。

2. C喜得贵子D。

怎么生成两条Relation的？我们可以先看一下增量Action在DB中的格式，如下图所示。

【此处有图】

我们会把一次UPDATE的操作按上图格式存储，其中包含变更修改前与修改后的payload,看到这条Action,修改前是  `{"cat_id":"300","parent_id":"100",...}` , 修改后是 `{"cat_id":"300",l'parent_id":"200",...}` ， 据此我们能够很容易地算出 父类目的变化。针对父类目变化的情况，产生一条DELETE的Relation记录”类目B少了D这个子类目“；再产生一条 ADD的Relation记录"类目C多了 D这个子类目"。

【此处有图】

这样，无论B还是C在获取所有子类目时，都有据可依，只需要从Relation中査询一下是否有关系的变更，并根据 Relation进行一次合并即可计算出最新的子类目信息。

那么在增量内存区中，其实分为两个部分，一部分存放各种Action， 另一部分存放各种Relation， 如下图。

【此处有图】

可以看到除了类目还有许多类型的Relation，不一一在此细说。

这么多业务逻辑，任意一处出错，都可能引起蝴蝶效应，如何保证增量和以前全量的逻辑一致呢？

在每天凌晨构建增量数据包时，会以全量数据的结构为参照，同时构建出当天的全量包与增量包，并在服务端启用两 个客户端一个读当天的全量包，另一个读当天的增量包加上前一天的全量包，两个客户端对所有类目所有属性所有属性值的所有字段做一一对比，如果出现不一致则马上切換为全量包推送，保证了增量数据包的可靠。

线上一天的增量Action通常在3W到10W条之间，打出的增量包大概是3M到10M，这样一个数据包即使推给类目重度用户，对客户端造成的抖动完全可以忽略。但是，线上整个数据包构建+推送过程耗时在2小时上下，依旧需要等到我心憔悴。



最尴尬的事莫如推包失败要重推。

## 小增量

"只改了个类目特征，想日常/预发验证一下，还得等那么久？”

有句话说得好——”青春可不能耗费在等forest推包啊！", 为了解这个问题，我们开发了小增量功能。顾名思义，就是只打一个很小的增量包，里面有哪些数据，任君挑选，秒秒钟完成打包+推包。操作手册在此，欢迎自取。 

# 终章

forest数据包的相关优化仍在持续进行中，增量是针对现有架构做的一次革命，是解决线上故障、提高效率的一大利器。

而本人作为forest受害者之一，私以为forest全量结构的设计还是相当巧妙的，而forest几年来产生的业务价值，绝不逊于'‘怪物"之称，在此向前辈们致敬。但随着类目属性数据的膨胀以及业务的高速发展，如果forest只有一个全量包，那么恐怕是要变成真正的"怪物"。听过温水煮青娃故事的人，恐怕也常常没有意识到自己就是那只青娃，希望我们这几只青娃，反应的还算快。

# 附录

1. `IC`使用的数据包`CairoCatForICDO heap dump`见下图。

   其中，`BSStructDatumIndex`即为后台泪目-属性-属性值索引，占用360M左右；`ClientStringDictionary`即为字典表，占用260M左右；`BSBasicIndex`即为基础属性属性值索引，占用130M左右。

2. 截止至2017年9月20日,数据包中类目相关数量统计如下表。

   | 数据类型   | 数量     |
   | ---------- | -------- |
   | 类目       | 32246    |
   | 基础厲性   | 491152   |
   | 基础属性值 | 3215229  |
   | CP         | 2251232  |
   | CPV        | 18097446 |
   | PV         | 5317929  |

3. 本文大部分数据都是使用CairoCatForICDO类型的数据包计算出来的（计算时间：2017年9月20日），如果各位想了解其它数据包的大致数据，可参考下表。比如Sell使用CairostdCatDO包，在各项IC数据包数据基础上，乘以86.2%, 即是大致估算值。

   | 数据包类型         | 较IC数据包占比 |
   | ------------------ | -------------- |
   | CairoCatForlCDO    | 100%           |
   | CairoStdCatDO      | 86.2%          |
   | CairoTmallStdCatDO | 89.2%          |
   | CairoAllDO         | 151.0%         |
   | CairoVerticalDO542 | 107.1%         |
   | CairoPropertyDO    | 34.1%          |

4. 如对文本类目相关名词不太了解，可阅读：类目体系高级手册

5. 如想了解Forest设计思路，可阅读：The New Forest:解析Forest 3.0的基本原理和设计思路

