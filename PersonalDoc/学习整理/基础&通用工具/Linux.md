# 进程

## Linux进程被信号杀死后退出状态码（exit code）解析

linux系统下，进程对信号的默认响应方式有5种：

1）  忽略信号，即当做没收到信号一样；

2）  终止进程；

3）  产生核心转储文件，同时进程终止；

4）  停止进程，即暂停进程的执行；

5）  于之前的暂停之后恢复执行；

处理方式2和3都会导致进程终止执行并立即退出，处理方式1、4、5不会造成进程终止执行。因此，可以将信号粗略的分为两类，一类是会导致进程终止并退出的信号；另一类则是不会导致进程终止并退出的信号。

 

当进程因收到信号被终止执行退出后，父进程可以通过调用wait或waitpid得到它的exit code。进程被各信号终止的退出状态码总结如下：

| 信号编号 | 信号名称  | 信号描述         | 默认处理方式     | Exit code |
| -------: | --------- | ---------------- | ---------------- | --------: |
|        1 | SIGHUP    | 挂起             | 终止             |         1 |
|        2 | SIGINT    | 终端中断         | 终止             |         2 |
|        3 | SIGQUIT   | 终端退出         | 终止、core  dump |       131 |
|        4 | SIGILL    | 非法指令         | 终止、core  dump |       132 |
|        5 | SIGTRAP   | 跟踪/断点陷阱    | 终止、core  dump |       133 |
|        6 | SIGABRT   | 终止进程         | 终止、core  dump |       134 |
|        7 | SIGBUS    | Bus  error       | 终止、core  dump |       135 |
|        8 | SIGFPE    | 算术异常         | 终止、core  dump |       136 |
|        9 | SIGKILL   | 杀死进程（必杀） | 终止             |         9 |
|       10 | SIGUSR1   | 用户自定义信号1  | 终止             |        10 |
|       11 | SIGSEGV   | 段错误           | 终止、core  dump |       139 |
|       12 | SIGUSR2   | 用户自定义信号2  | 终止             |        12 |
|       13 | SIGPIPE   | 管道断开         | 终止             |        13 |
|       14 | SIGALRM   | 定时器信号       | 终止             |        14 |
|       15 | SIGTERM   | 终止进程         | 终止             |        15 |
|       16 | SIGSTKFLT | 栈错误           | 终止             |        16 |
|       17 | SIGCHLD   | 子进程退出       | 忽略             |        无 |
|       18 | SIGCONT   | 继续执行         | 若停止则继续执行 |        无 |



 

进一步总结如下：

1.    能使进程被终止执行并产生core dump的信号，它的退出状态码是信号编号+128，比如SIGQUIT信号，它的编号为3，进程收到该信号后会core dump，退出状态码为3+128=131；

2.    只是使进程被终止，而不会产生core dump的信号，它的退出状态码就是信号本身的编号。



# 文本文件比对

命令基本格式

```bash
diff [option]... FILES
```

常见参数如

- -b	——忽略一行中空字符的区别
- -B    ——忽略空白行
- -i     ——忽略大小写的不同
- -r    ——如果diff后面接的目录时，会递归比较目录中的文件

diff命令输出格式有三种

1. 正常格式
2. 上下文格式——增加参数 `-c`
3. 合并格式——增加参数 `-u`

示例演示如下

| a.txt                                         | b.txt                               |
| --------------------------------------------- | ----------------------------------- |
| 432<br/>31231<br/>111222333<br/>123<br />1234 | 432<br/>31231<br/>111222333<br/>123 |

执行命令

```bash
➜  cmp_text diff text1.txt text2.txt
4,5c4
< 123
< 1234
\ No newline at end of file
---
> 123
\ No newline at end of file
```

解释下其中结果

第一行：4,5c4

​	4,5表示第一个文件4～5行有变化，后面的4表示第一个文件通过变化称为第二个文件的第4行。中间的c见识变化的行为。其中c表示改变（change），d删除（delete），a增加（addition）

第2～3行

​	表示第一个文件去除两行内容，其中`<` 表示去除

第6行： `> 123` 

​	表示第二个文件增加第6行的内容，其中 `>` 表示增加



# cat合并多个文件

```bash
cat db1.sql db2.sql db3.sql > db_all.sql # 当然也可以指定合并哪几个文件 

cat a.txt >> b.txt # 将a.txt的内容输入到b.txt的末尾

```



# 查看文件命令

1. `ls`——查看文件名列表

2. `ll`——查看文件列表详情，包含修改时间，文件大小等参数

3. `ll -lrt` ——按时间顺序排序展示文件列表详情

   





参考：

1. [教你一招实现Linux中的文本比对](https://www.jb51.net/article/150038.htm)
